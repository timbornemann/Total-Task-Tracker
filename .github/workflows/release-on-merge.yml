name: Create Release on merge to production

on:
  pull_request:
    types: [closed]
    branches: [production]

permissions:
  contents: write   # nötig für Push/Tag/Release
  pull-requests: read

jobs:
  release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read current version from VERSION
        id: curver
        run: |
          if [ -f VERSION ]; then
            CUR=$(tr -d ' \t\r\n' < VERSION)
          else
            CUR="0.0.0"
          fi
          if [[ ! "$CUR" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Bad VERSION '$CUR' (expected MAJOR.MINOR.PATCH)"; exit 1
          fi
          echo "cur=$CUR" >> $GITHUB_OUTPUT

      - name: Decide bump (labels > commit messages > default patch)
        id: bump
        run: |
          CUR="${{ steps.curver.outputs.cur }}"
          IFS='.' read -r MA MI PA <<<"$CUR"

          # 1) PR-Labels: major/minor/patch (case-insensitive)
          LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
          lcl=$(echo "$LABELS" | tr '[:upper:]' '[:lower:]')
          if echo "$lcl" | grep -q "\bmajor\b"; then
            TYPE=major
          elif echo "$lcl" | grep -q "\bminor\b"; then
            TYPE=minor
          elif echo "$lcl" | grep -q "\bpatch\b"; then
            TYPE=patch
          else
            # 2) Conventional commits im Merge-Bereich
            BASE="${{ github.event.pull_request.base.sha }}"
            MERGE="${{ github.event.pull_request.merge_commit_sha }}"
            BREAK=$(git log "$BASE..$MERGE" --grep="BREAKING CHANGE:" --oneline | wc -l || echo 0)
            FEAT=$(git log "$BASE..$MERGE" --grep="^feat" --oneline | wc -l || echo 0)
            if [ "$BREAK" -gt 0 ]; then TYPE=major
            elif [ "$FEAT" -gt 0 ]; then TYPE=minor
            else TYPE=patch
            fi
          fi

          case "$TYPE" in
            major) MA=$((MA+1)); MI=0; PA=0 ;;
            minor) MI=$((MI+1)); PA=0 ;;
            patch) PA=$((PA+1)) ;;
          esac
          NEW="$MA.$MI.$PA"
          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "new=$NEW" >> $GITHUB_OUTPUT
          echo "Bump: $CUR -> $NEW ($TYPE)"

      - name: Update VERSION file, commit & push
        run: |
          echo "${{ steps.bump.outputs.new }}" > VERSION
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add VERSION
          git commit -m "chore(release): bump version to ${{ steps.bump.outputs.new }}"
          git push origin HEAD:production

      - name: Pick release notes file (project-provided or fallback)
        id: notes
        run: |
          FILE=".github/release-notes.md"
          [ -f "$FILE" ] || FILE="RELEASE_NOTES.md"
          if [ -f "$FILE" ]; then
            echo "file=$FILE" >> $GITHUB_OUTPUT
          else
            # Fallback: Commits des gemergten PRs
            BASE="${{ github.event.pull_request.base.sha }}"
            MERGE="${{ github.event.pull_request.merge_commit_sha }}"
            git log "$BASE..$MERGE" --pretty=format:"- %s" > release_notes.md
            echo "file=release_notes.md" >> $GITHUB_OUTPUT
          fi

      - name: Create tag & GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.bump.outputs.new }}          # ohne 'v'? -> ändere diese Zeile
          target_commitish: production
          body_path: ${{ steps.notes.outputs.file }}
          draft: false
          prerelease: false
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
