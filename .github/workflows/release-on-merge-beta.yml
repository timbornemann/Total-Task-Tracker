name: Create Beta Pre-Release on merge to beta

on:
  pull_request:
    types: [closed]
    branches: [beta]

permissions:
  contents: write
  pull-requests: read

jobs:
  prerelease:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read base version from VERSION
        id: basever
        run: |
          if [ ! -f VERSION ]; then echo "VERSION not found"; exit 1; fi
          BASE=$(tr -d ' \t\r\n' < VERSION)
          [[ "$BASE" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "Bad VERSION '$BASE'"; exit 1; }
          echo "base=$BASE" >> $GITHUB_OUTPUT

      # Optional: automatische Hochzähl-Logik wie bei production (Labels/Commits).
      # Wenn du für Beta IMMER auf derselben BASIS bleiben willst, lösche diesen Step.
      - name: Decide bump (optional; labels>commits>patch)
        id: bump
        run: |
          CUR="${{ steps.basever.outputs.base }}"
          IFS='.' read -r MA MI PA <<<"$CUR"
          LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
          lcl=$(echo "$LABELS" | tr '[:upper:]' '[:lower:]')
          if echo "$lcl" | grep -q "\bmajor\b"; then TYPE=major
          elif echo "$lcl" | grep -q "\bminor\b"; then TYPE=minor
          elif echo "$lcl" | grep -q "\bpatch\b"; then TYPE=patch
          else
            BASESHA="${{ github.event.pull_request.base.sha }}"
            MERGESHA="${{ github.event.pull_request.merge_commit_sha }}"
            BREAK=$(git log "$BASESHA..$MERGESHA" --grep="BREAKING CHANGE:" --oneline | wc -l || echo 0)
            FEAT=$(git log "$BASESHA..$MERGESHA" --grep="^feat" --oneline | wc -l || echo 0)
            if [ "$BREAK" -gt 0 ]; then TYPE=major
            elif [ "$FEAT" -gt 0 ]; then TYPE=minor
            else TYPE=patch
            fi
          fi
          case "$TYPE" in
            major) MA=$((MA+1)); MI=0; PA=0 ;;
            minor) MI=$((MI+1)); PA=0 ;;
            patch) PA=$((PA+1)) ;;
          esac
          NEW="$MA.$MI.$PA"
          echo "base_bumped=$NEW" >> $GITHUB_OUTPUT

      - name: Compute prerelease tag (v<base>-beta.N)
        id: tag
        run: |
          BASE="${{ steps.bump.outputs.base_bumped || steps.basever.outputs.base }}"
          # vorhandene beta-Tags für diese Basis zählen
          COUNT=$(git tag -l "v${BASE}-beta.*" | wc -l | tr -d ' ')
          N=$((COUNT + 1))
          TAG="v${BASE}-beta.${N}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version_prerelease=${BASE}-beta.${N}" >> $GITHUB_OUTPUT

      - name: Pick release notes
        id: notes
        run: |
          FILE=".github/release-notes.beta.md"
          [ -f "$FILE" ] || FILE=".github/release-notes.md"
          [ -f "$FILE" ] || FILE="RELEASE_NOTES.md"
          if [ -f "$FILE" ]; then
            echo "file=$FILE" >> $GITHUB_OUTPUT
          else
            BASESHA="${{ github.event.pull_request.base.sha }}"
            MERGESHA="${{ github.event.pull_request.merge_commit_sha }}"
            git log "$BASESHA..$MERGESHA" --pretty=format:"- %s" > release_notes.md
            echo "file=release_notes.md" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Pre-Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          target_commitish: beta
          body_path: ${{ steps.notes.outputs.file }}
          draft: false
          prerelease: true         # ⟵ wichtig: „nicht production ready“
          make_latest: false       # ⟵ Beta soll nicht „Latest“ überdecken
          name: "Beta ${{ steps.tag.outputs.tag }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
